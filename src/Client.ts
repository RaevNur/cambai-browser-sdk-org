// This file was auto-generated by Fern from our API Definition.

import { AudioSeparationClient } from "./api/resources/audioSeparation/client/Client.js";
import { DeprecatedStreamingClient } from "./api/resources/deprecatedStreaming/client/Client.js";
import { DictionariesClient } from "./api/resources/dictionaries/client/Client.js";
import { DubClient } from "./api/resources/dub/client/Client.js";
import { FoldersClient } from "./api/resources/folders/client/Client.js";
import { LanguagesClient } from "./api/resources/languages/client/Client.js";
import { ProjectSetupClient } from "./api/resources/projectSetup/client/Client.js";
import { StoryClient } from "./api/resources/story/client/Client.js";
import { StreamingClient } from "./api/resources/streaming/client/Client.js";
import { TextToAudioClient } from "./api/resources/textToAudio/client/Client.js";
import { TextToSpeechClient } from "./api/resources/textToSpeech/client/Client.js";
import { TextToVoiceClient } from "./api/resources/textToVoice/client/Client.js";
import { TranscriptionClient } from "./api/resources/transcription/client/Client.js";
import { TranslatedStoryClient } from "./api/resources/translatedStory/client/Client.js";
import { TranslatedTtsClient } from "./api/resources/translatedTts/client/Client.js";
import { TranslationClient } from "./api/resources/translation/client/Client.js";
import { VoiceCloningClient } from "./api/resources/voiceCloning/client/Client.js";
import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "./BaseClient.js";
import { mergeHeaders } from "./core/headers.js";
import * as core from "./core/index.js";
import * as environments from "./environments.js";
import { handleNonStatusCodeError } from "./errors/handleNonStatusCodeError.js";
import * as errors from "./errors/index.js";

export declare namespace CambClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions { }
}

export class CambClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<CambClient.Options>;
    protected _audioSeparation: AudioSeparationClient | undefined;
    protected _dub: DubClient | undefined;
    protected _folders: FoldersClient | undefined;
    protected _languages: LanguagesClient | undefined;
    protected _story: StoryClient | undefined;
    protected _translatedStory: TranslatedStoryClient | undefined;
    protected _textToAudio: TextToAudioClient | undefined;
    protected _textToVoice: TextToVoiceClient | undefined;
    protected _textToSpeech: TextToSpeechClient | undefined;
    protected _translation: TranslationClient | undefined;
    protected _transcription: TranscriptionClient | undefined;
    protected _translatedTts: TranslatedTtsClient | undefined;
    protected _streaming: StreamingClient | undefined;
    protected _voiceCloning: VoiceCloningClient | undefined;
    protected _dictionaries: DictionariesClient | undefined;
    protected _projectSetup: ProjectSetupClient | undefined;
    protected _deprecatedStreaming: DeprecatedStreamingClient | undefined;

    constructor(options: CambClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get audioSeparation(): AudioSeparationClient {
        return (this._audioSeparation ??= new AudioSeparationClient(this._options));
    }

    public get dub(): DubClient {
        return (this._dub ??= new DubClient(this._options));
    }

    public get folders(): FoldersClient {
        return (this._folders ??= new FoldersClient(this._options));
    }

    public get languages(): LanguagesClient {
        return (this._languages ??= new LanguagesClient(this._options));
    }

    public get story(): StoryClient {
        return (this._story ??= new StoryClient(this._options));
    }

    public get translatedStory(): TranslatedStoryClient {
        return (this._translatedStory ??= new TranslatedStoryClient(this._options));
    }

    public get textToAudio(): TextToAudioClient {
        return (this._textToAudio ??= new TextToAudioClient(this._options));
    }

    public get textToVoice(): TextToVoiceClient {
        return (this._textToVoice ??= new TextToVoiceClient(this._options));
    }

    public get textToSpeech(): TextToSpeechClient {
        return (this._textToSpeech ??= new TextToSpeechClient(this._options));
    }

    public get translation(): TranslationClient {
        return (this._translation ??= new TranslationClient(this._options));
    }

    public get transcription(): TranscriptionClient {
        return (this._transcription ??= new TranscriptionClient(this._options));
    }

    public get translatedTts(): TranslatedTtsClient {
        return (this._translatedTts ??= new TranslatedTtsClient(this._options));
    }

    public get streaming(): StreamingClient {
        return (this._streaming ??= new StreamingClient(this._options));
    }

    public get voiceCloning(): VoiceCloningClient {
        return (this._voiceCloning ??= new VoiceCloningClient(this._options));
    }

    public get dictionaries(): DictionariesClient {
        return (this._dictionaries ??= new DictionariesClient(this._options));
    }

    public get projectSetup(): ProjectSetupClient {
        return (this._projectSetup ??= new ProjectSetupClient(this._options));
    }

    public get deprecatedStreaming(): DeprecatedStreamingClient {
        return (this._deprecatedStreaming ??= new DeprecatedStreamingClient(this._options));
    }

    public getSwaggerDocsDocsGet(requestOptions?: CambClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getSwaggerDocsDocsGet(requestOptions));
    }

    private async __getSwaggerDocsDocsGet(
        requestOptions?: CambClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                (await core.Supplier.get(this._options.environment)) ??
                environments.CambApiEnvironment.Default,
                "docs",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CambApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/docs");
    }

    /**
     * @param {CambClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getRedocDocsRedocsGet()
     */
    public getRedocDocsRedocsGet(requestOptions?: CambClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getRedocDocsRedocsGet(requestOptions));
    }

    private async __getRedocDocsRedocsGet(
        requestOptions?: CambClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                (await core.Supplier.get(this._options.environment)) ??
                environments.CambApiEnvironment.Default,
                "redocs",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CambApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/redocs");
    }

    /**
     * @param {CambClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getOpenapiSchemaOpenapiJsonGet()
     */
    public getOpenapiSchemaOpenapiJsonGet(
        requestOptions?: CambClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getOpenapiSchemaOpenapiJsonGet(requestOptions));
    }

    private async __getOpenapiSchemaOpenapiJsonGet(
        requestOptions?: CambClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                (await core.Supplier.get(this._options.environment)) ??
                environments.CambApiEnvironment.Default,
                "openapi.json",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CambApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/openapi.json");
    }
}
